# 프로그래머스: 가장 큰 수 (정렬)

[문제: 가장 큰 수 (정렬
)](https://programmers.co.kr/learn/courses/30/lessons/42746)


<br/>

# 문제파악

1. 정수를 이어붙여 만들 수 있는 가장 큰수
2. 문자열로 리턴
3. number의 원소는 0이상 1,000이하


<br/>

# 코드풀이

## 비교 문자열을 2개를 연결하여 비교

```jsx
function solution(numbers) {
    let answer = numbers.map(el => el+'').sort((a,b) => (b+a) - (a+b)).join('');

//0이 가장 앞에 오는 경우는 0일때 밖에 없다.
   return answer[0] === '0' ? '0' : answer;
}
```

1. 두 수를 하나의 수로 만들어서 sort 메서드를 이용해 알고리즘의 삽입정렬 개념을 이용하여 비교한다.

2. 문자열로 전환 시, map을 이용하여 전환한다.


<br/>

## 문자열의 길이를 4배로 늘린 후 비교

```jsx
def solution(numbers):
    numbers = [ str(x) for x in numbers ]
    numbers.sort(key=lambda x: (x*4)[:4], reverse=True)
    answer = "".join(numbers) if numbers[0] != "0" else "0"
    return answer
```

타 언어(예시는 파이썬)의 예시를 보니 정렬 할 숫자의 길이를 4배로 늘려 준 후에 4자리까지 잘라서 정렬할 값을 비교했다. (4배로 늘리는 이유는 number의 원소가 1000이하이기 때문)


<br/>


# 정리

가장 popular한 문제풀이 두개를 가져와봤는데 결국 이 문제는 **'어떤 기준으로 정렬할 것인가'**가 관건인 것 같다.

JS의 경우에는 sort라는 메서드가 있는데 해당 메서드에서 옵션으로 정렬기준을 넣어주면 해당 정렬기준으로 정렬해준다.

따라서, 정렬순서를 정의해주는 비교함수를 인수로 전달해줘야한다.

- 비교함수 반환값 < 0 → 비교함수의 첫번재 인수를 우선정렬, 즉, 오름차순
- 비교함수 반환값 > 0 → 비교함수의 두번재 인수를 우선정렬, 즉, 내림차순

위 문제의 경우에는 문자열 두개를 앞뒤로 연결시켜 하나의 문자열을 만든 후, 숫자를 비교하여 큰 수가 앞으로 오도록 만들었다.

마치 알고리즘의 삽입정렬과 같이 작동하는 것 같다. [제로초: 알고리즘(삽입정렬)](https://www.zerocho.com/category/Algorithm/post/57e39fca76a7850015e6944a)

마지막에는 예외처리를 위해서 모든 문자가 0으로 이뤄졌을 때 '0000'과 같은 결과가 나오지 않게 하기 위한 처리를 해줬다. 왜냐면 0은 아무리 자리수가 많아져도 0으로 표기하니까.


<br/>


# 타인의 지혜를 엿보고 내것으로 만들자.

내가 처음 생각했던 건 각 자리수마다 비교(1의자리, 10의자리, 100의자리, 1000의자리)하는 거였는데 이건 아무리봐도 코드가 길어질 것 같고 딱 봐도 별로 효율적이지 못할 것 같단 생각을 했다.

일정시간동안 답을 찾지 못한다면 모른다는 거다. 그 때에는 차라리 타인의 아이디어를 찾아보고 그 것을 내것으로 만드는 것이 시간적으로나 지식적으로나 훨씬 더 효과적이라고 생각한다. 

물론, 찾아보고 '아하'하고 끝내면 그대로 휘발되기 때문에 논리를 잘 생각해보고 정리해서 내것으로 만들자.


<br/>
